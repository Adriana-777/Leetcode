//题目描述：
     给定一个非严格递增排列的数组（即数组是递增的但有可能出现相同的元素），原地删除重复的元素（即可覆盖），
     使每个元素只出现一次且相对顺序不变，返回删除后数组的长度。

//算法思路：
  1.暴力求解：使用额外的数组，空间复杂度为O(n)
  2.双指针：快慢指针
      **因为数组非严格递增，因此对于任意 i<j，如果 nums[i]=nums[j],则对任意 i≤k≤j 必有 nums[i]=nums[k]=nums[j]即相等的元素在数组中的下标一定是连续的
      **分类讨论：
            当数组长度为0，即不包含任何元素，则返回0.
                    if not nums:
                       return 0
            当数组nums的长度大于0时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0]保持原状即可，从下标1开始删除重复元素。
            快指针指向下一个将要遍历的元素；慢指针指向下一个将要填入不同元素的位置，两个指针都从1开始， 1<fast<n-1
            if nums[fast] != nums[fast - 1] 则表示nums[fast]与之前的所有元素不相同，then nums[slow] = nums [fast], slow+1
            返回slow，slow即为最后数组的长度。
            


